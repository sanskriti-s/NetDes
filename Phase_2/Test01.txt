10010000 00101001
11110001 11110100

Sum: 98845
Result (wrap around): 33310
Max Int: 65535

class ServerThread(multiprocessing.Process):
    def __init__(self):  # function to initiate the class
        multiprocessing.Process.__init__(self)

    def run(self):  # the actual run of the background process
        # The server port and buffer are set to the same as the client
        serverPort = 12002
        buf = 6000
        # The UDP socket is created same as the client.
        # AF_INET indicates that the underlying network is using IPv4.
        # SOCK_DGRAM means it is a UDP socket (rather than a TCP socket.)
        serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # The port number 12000 is bound to the servers socket.
        serverSocket.bind(('', serverPort))

        # Deleting temporary files if they exists
        if os.path.exists("temp.bin"):
            os.remove("temp.bin")
        if os.path.exists("final.bmp"):
            os.remove("final.bmp")

        message = []
        # Enters an indefinite loop
        while True:
            self.QUEUE.put("Prepared to receive image data...\n")
            receiveFile = True
            while receiveFile:
                # The message is received from the client and the client address is saved
                output, clientAddress = serverSocket.recvfrom(buf)
                packet = self.sortData(output)
                # Check the output's checksum
                checksum = self.generateChecksum(packet["Message_Int"], packet["SN"], False)
                if self.verifyChecksum(packet["Checksum"], checksum):
                    message.append(packet["Message"])
                    if packet["Message"] == b'':
                        receiveFile = False

            # Write message to a file
            with open('temp.bin', 'ab+') as file:
                for n in range(len(message)):
                    file.write(message[n])

            image = Image.open("temp.bin")
            try:
                image.show()
                self.QUEUE("... Finished image transfer successfully\n")
                # The image is converted to greyscale and saved to modifiedImage
                modifiedImage = image.convert('L')
                # The pixel values of the image are converted into a byte array
                imgByteArr = io.BytesIO()
                # modifiedImage.save(imgByteArr, format='BMP')
                modifiedImage.save('final.bmp')
            except OSError:
                self.QUEUE.put("Error: Image transfer corrupted\n")

    def pipeLine(self, telephone):
        self.QUEUE = telephone

    # Generate the checksum for the given 1kB chunk of data, and the given IPA, PORT, and SN
    def generateChecksum(self, data, sn, flag):
        a = sn
        d = bin(data)[2:]
        for x in range(0, 511):
            temp = a
            try:
                a += int(d[(16 * x): (15 + (16 * x))], 2)
                if a > 65536:
                    a -= 65536
                    a += 1
            except ValueError:
                a = temp
        if flag:
            return int(bin(a).translate(str.maketrans("10", "01"))[2:], 2)
        else:
            return a

    # Check if two checksums are valid for the given received data
    def verifyChecksum(self, value, checksum):
        verify = bin(value ^ checksum)
        checker = (2 ** (len(verify) - 2)) - 1
        if int(verify, 2) == checker:
            return True
        return False

    # Sort the incoming data into its component forms, and return a dictionary of this information
    def sortData(self, data):
        dictionary = {}
        dictionary["SN"] = data[0]  # sequence number leads the data received (1x2 bytes long)
        dictionary["Checksum"] = int.from_bytes(data[1:4], byteorder="little")  # the checksum is before the message data received (4x2 bytes long)
        dictionary["Message"] = data[5:]  # message data received (1024 bytes long)
        dictionary["Message_Int"] = int.from_bytes(data[5:], byteorder="little")  # converted message data into an integer
        return dictionary

    def kill(self):  # Function definition to kill the running process in a multiprocessing situation
        os.kill(self.pid, signal.SIGABRT)
